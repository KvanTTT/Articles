# Идеальный генератор парсеров

## Оператор проверки значения токена

Во многих языках, например в SQL диалектах, существует большое количество
слов, которые являются ключевыми, но только в определенных контекстах.
Классическое решение данной проблемы - заносить все такие ключевые слова в
правило идентификатора:

```antlr
identifier : ID | GET | /* other keywords */
```

Несмотря на то, что такое решение универсально, оно далеко не идеально, т.к. ключевых
контекстных ключевых слов может быть очень много, и можно попросту
забыть про какое-то. Более того, большое количество альтернатив может замедлить
работу парсера.

Другой способ заключается в получении значения токена-идентификатора и распознавании
нужного правила в зависимости от него. Это можно сделать только с помощью вставки
кода, которая, к сожалению, ограничивает область применения грамматики только java
рантаймом.

```antlr
getter : {_input.LT(1).getText().equals("get")}? Identifier propertyName;
```

Для того чтобы избежать такой зависимости и сделать грамматику по настоящему
универсальной, можно ввести специальную конструкцию для сравнения значения
токена с определенным:

```antlr
getter : Identifier=='get' propertyName;
```

Эта фича также предложена на GitHub: [Token value comparison operator](https://github.com/antlr/antlr4/issues/1965).

## Универсальные вставки кода

Cуществуют синтаксические конструкции, которые не охватить даже дополнительным
синтаксисом, а нужно использовать какие-то вычисления для корректного парсинга.
Например, [интерполяция строк](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated)
в C# или PHP. Как уже выше упоминалось, в ANTLR
для таких вычислений можно использовать *семантические предикаты* или *действия*.
Однако они не являются универсальными.

С помощью определенных трюков их можно обобщить на несколько рантаймов, как это
сделано в грамматике ANTLR [JavaScript](https://github.com/antlr/grammars-v4/tree/master/javascript).
Однако такой подход не является идеальным, поскольку абстрагирование парсера -
это дополнительный сложный этап. Такие вставки кода все равно являются чужеродными,
они плохо интегрируются со сгенерированным кодом, т.к. он не проверяется во время
генерации парсера из грамматики, плохо форматируется. Кроме того, грамматические
IDE не могут хорошо работать с ними.

**Универсальный DSL** для описания семантических предикатов решил бы все указанные
проблемы, был бы лаконичным и более заточенным под специфику парсеров.
Благодаря симбиозу декларативного подхода (контекстно-свободная грамматика)
и императивного (универсальные вставки), можно было бы удобно разрабатывать
парсеры на всевозможные случаи!

Например, инструкция `la(-1)`, взятие предыдущего символа, будет транслироваться
в код `_input.LA(-1)` в Java рантайме и в код `self._input.LA(1)` в Python
рантайме. Более подробнее про универсальные вставки кода расписано на
[GitHub](https://github.com/antlr/antlr4/issues/1045).

## Достоверное дерево разбора

В ANTLR есть механизм каналов, который позволяет изолировать множество скрытых
токенов (пробелов, комментариев) от основных. Однако такие токены не привязаны к
узлам дерева разбора, которое получается в результате парсинга. Кроме скрытых,
есть еще и нераспознанные (ошибочные) символы, для которых не подошло ни одно
лексическое правило и ошибочные токены, для которых не подошли грамматические
альтернативы.

**Связанность** таких токенов с узлами дерева разбора очень важна, т.к. благодаря
такой структуре становится возможным, например, учитывать стиль кода при его
трансформациях и рефакторинге. Более того, анализируя лишь только дерево разбора
и пробелы, можно обнаружить серьезные недостатки в исходных кодах, например,
[goto fail](https://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/).

Подробнее на GitHub:

* [Create parse trees whose leaves have left/right hidden token text](https://github.com/antlr/antlr4/pull/1667)
* [Error recovery should create missing tokens for first path to recovery point](https://github.com/antlr/antlr4/issues/1972)

## Соблюдение стиля кода рантайма

В ANTLR *лексически*е правила записываются с первой буквой в верхнем регистре, а
правила *парсера* - в нижнем. Рантаймы, под которые генерируется код, имеют свой
code-style, который совсем не учитывается при трансформации правил. Более того,
сгенерированный код вообще оказаться невалидным из-за того, что определенные
идентификаторы могут быть зарезервированы под ключевые слова (issues с меткой
[symbol-conflict](https://github.com/antlr/grammars-v4/issues?utf8=%E2%9C%93&q=label%3Asymbol-conflict+)
в репозитории). Из-за этого приходится терять в универсальности или как-то
подстраиваться под рантайм и переименовывать правила.

Можно  менять правила не в самой грамматике, а адаптировать идентификаторы под
каждый конкретный рантайм. Таким образом, грамматика не будет никак зависеть от
рантайма, а код визиторов не будет похож на сгенерированный.

Подробнее на GitHub:

* [Add a new option for naming convention of generated Visitor and Listener methods](https://github.com/antlr/antlr4/issues/1615)
* [Throw warning if symbol conflicts with generated code in another language or runtime](https://github.com/antlr/antlr4/issues/1670)

## Парсинг без токенов

Существуют языки и синтаксические конструкции, в которых стадии токенизации,
парсинга и семантического анализа сильно переплетены. Например, в С-языках
конструкция `x * y` может интерпретироваться и как умножение, и как
объявление указателя: данная неоднозначность разрешается с использованием таблицы
символов. А в популярном текстовом формате [Markdown](https://en.wikipedia.org/wiki/Markdown)
вообще не существует ошибок парсинга: каждый символ интерпретируется либо
как символ, который обозначает какой-то элемент форматирования, либо же трактуется
как обычный текст.

Например, если написать так: `[ссылка](https://google.com)`, то в результате
это преобразуется в [ссылку](https://google.com). Если же убрать последнюю скобку,
то данный синтаксис просто текстом `[ссылка](https://google.com`.

Описание также доступно на GitHub: [Add scannerless tokenizer to runtime jar](https://github.com/antlr/antlr4/issues/814).

## Онлайн редактор и обозревать грамматик

Для разработки и отладки ANTLR грамматик существует плагины к популярным IDE,
например [ANTLR intellij-plugin-v4](https://plugins.jetbrains.com/plugin/7358-antlr-v4-grammar-plugin),
[vscode-antlr4](https://marketplace.visualstudio.com/items?itemName=mike-lischke.vscode-antlr4).
Однако они не позволяют разрабатывать грамматики без IDE, сразу под все рантаймы,
и, самое главное, они работают оффлайн. Т.е. для тестирования даже чего-то
небольшого, пользователю необходимо устанавливать и настраивать дополнительные
инструменты.

Было бы намного удобнее тестировать грамматики сразу онлайн, в браузере. У
пользователя был бы выбор: создать свой язык или воспользоваться уже готовой
грамматикой из официального репозитория [grammars-v4](https://github.com/antlr/grammars-v4),
чтобы посмотреть дерево разбора для определенного фрагмента кода. Функциональность
по внесению фиксов сразу в репозиторий была бы еще удобней.

С помощью сервиса <http://astexplorer.net/>, можно строить дерево разбора
только для определенных языков (JavaScript, CSS), однако грамматику изменять нельзя.

В качестве демонстрации концепта было разработано десктопное приложение с
открытым исходным кодом, [Desktop Antlr Grammar Editor (DAGE)](https://github.com/KvanTTT/DAGE).
В нем в окне слева расположено поле для редактирования грамматики, а справа -
для редактирования языка. И для грамматики и для кода могут быть
соответствующие ошибки на разных уровнях генерации парсера.

## Заключение

Предложенные фичи расширяют возможности стандартных контекстно-свободных
грамматик а также унифицируют API и сгенерированный код. Это делает разработку
парсеров на базе ANTLR более удобной.

Веб-версия редактора грамматик автоматизирует и упрощает сам процесс разработки,
снижает порога входа в предметную область.

Реализация данных предложений привлечет больше разработчиков разных уровней и
использующих разные языки. Начинающий сможет быстро и просто приступить к
созданию собственной грамматики, а опытный - оперативно помочь с фиксами
существующей. Более того, грамматика будет общей вне зависимости от выбранного
рантайма.