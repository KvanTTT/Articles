# Генеалогическое дерево внутри Git

Поздравляю всех программистов с их профессиональным днем, желаю меньше багов и
больше-либо-равно классных идей! А в качестве идейного подарка предлагаю
реализацию одной интересной и безумной задачи: создании генеалогического
дерева средствами системы контроля версий Git. Ну что же, звучит как план!

<table>
  <tr>
    <td width=100><img src=Git.svg ></td>
    <td>Напомню, что Git - одна из самых популярных систем контроля версий. Она
      мощная: в ней можно фиксировать изменения (commit), создавать и сливать ветви
      (merge), сравнивать разные версии файлов (diff), вычислять авторов конкретных
      строк (blame), а также делать многие других вещей.</td>
  </tr>
</table>

К счастью или к сожалению, Git в чем-то похож на государство-победителя: он
позволяет менять историю, а именно менять даты, описания и авторов коммитов.
Но это наоборот играет на руку, поскольку это позволяет коммитить членов семьи,
как будто они авторы событий, сделанных в конкретную дату.

Исходники: [GenealogyTreeInGit](https://github.com/KvanTTT/GenealogyTreeInGit.git).

<cut>

Начал я с простого: написал несколько команд и вуала: фрагмент дерева готов!

## Gedcom

<table>
  <tr>
    <td width=100><img src=Gedcom.svg ></td>
    <td>Gedcom - формат описания генеалогических деревьев. Довольно старый, но
        текстовый и в целом простой. Поддерживается чуть ли не всеми
        генеалогическими программами, поэтому примеров для него существует много,
        например дерево президентов США или королевской семьи.</td>
  </tr>
</table>

Спецификация формат неплохо описана в интернете, так что дополнительно описывать
в статье я его не буду.

Реализовывал все это безобразие на [.NET Core](https://www.microsoft.com/net/learn/get-started-with-dotnet-tutorial) -
он удобный и кроссплатформенный. Для парсинга и обработки существует несколько
библиотек под C#: [GeneGenie.Gedcom](https://github.com/TheGeneGenieProject/GeneGenie.Gedcom),
[gedcomx-csharp](https://github.com/FamilySearch/gedcomx-csharp) и другие.
Я решил использовать адаптировать простенькую либу [GedcomParser](https://github.com/jaklithn/GedcomParser),
чтобы полностью избавиться от зависимостей и реализацию можно было бы легко и
быстро портировать на другие языки.

## Генерация команд

Настал момент обхода извлеченных в удобном для нас формате личностей и генерации
команд Git для них. Было решено отсортировать все события в хронологическом
порядке и создавать ветки, мержить и коммитить их продвигая в порядке возрастания
дат. К сожалению, не у всех событий есть даты, поэтому пришлось изрядно повозиться
чтобы отсортировать все события правильно.

### Инициализация

Все что требуется на этом этапе - инициализировать репозиторий. Изи!

```
mkdir Family
cd Family
git init
```

### События

В этой части скрипта обходятся и коммитятся все события. Изи, хотя посложнее.

Для создания этого безобразия потребовалось всего три базовых команды:

* `git checkout --orphan branch_name`
* `git merge @I1@ --allow-unrelated-histories --no-commit`
* `git commit -m "msg" --date "" --author "name <email>" --allow-empty`

С помощью первой создается ветвь для каждой личности. `--orphan` позволяет
создавать ветки-сироты, т.е. ветки не имеющие родителей. Не волнуйтесь, сиротами
они долго не пробудут, сделаем как мы им родителей! Пожалуй, единственными рутами
будут самые далекие предки, да и только потому что для них неизвестны более ранние
предки (во всяком случае пока что).

Вторая команда `merge` мержит родителей и создает ребенка. Будем писать в сообщении
коммита Birth - рождение с соответствующим годом. Также указываем флаги
`--allow-unrelated-histories` и `--no-commit` для того чтобы была возможность
мержить ветки-сироты и для того чтобы закоммитить изменения позже.
Некоторые дети являются приемными, поэтому для них будем писать Adopted.
Забавно, но Git позволяет создавать шведские семьи, т.е. мержить одновременно
несколько веток. А так как ветки не имеют пола, то можно создавать семьи,
например, с родителями-геями. Однако в этом случае дети будут всегда приемными
(по крайней мере до тех пор пока не будет зарегистрировано рождение ребенка от мужчины).

Наконец, третья команда `commit` создает коммит с соответствующим сообщением `-m`,
датой `--date` и автором `--author`. Напомню, что что Git позволяет подменять автора
и дату коммита, что очень на руку для создания генеалогических деревьев.
Более того, Git даже позволяет создавать коммиты без файлов с помощью
`--allow-empty` и без сообщений с помощью `--allow-empty-message`. У автора также
необходимо указывать электронную почту, но Git принимает и пустую - нужно просто
передать `<>`. К сожалению, дата коммита почему-то ограничена 1 январем 1970 года,
если задать дату раньше, то она будет неправильно отображаться.
Однако все не так страшно: можно просто записывать реальную дату в описание.
Забавно, но будущие даты Git принимает (обратите внимание на моего будущего сына
Гит). Матерей- и отцов-одиночек, кстати, тоже можно создавать.

Помимо событий "рождение", коммитить можно и другие события, такие как крещение,
изменение места жительства, получение образования, женитьбу, развод, смерть,
похороны и другие. После смерти ~~ветвь попадает в рай~~ в ветви не может
быть больше никаких событий, кроме разве что похорон. На сервере такую ветвь вообще
можно запечатать, т.е. сделать [protected branch](https://help.github.com/articles/about-protected-branches/)
(не волнуйтесь: в будущем "воскресить" можно будет при необходимости).
События, в которых участвует более одного человека, не особо вписываются в нашу
концепцию, однако их также можно сохранять и делать нескольких авторов вместо одного.
Например, событие "Свадьба" будет иметь двух родителей - супругов, при этом автором
будет тоже два человека. А событие "Развод" имеет одного родителя - предыдущее
событие "Свадьба". Над семейной жизнью надо работать как и над детьми, поэтому
можно сказать что после свадьбы появляется еще и новый ребенок "отношения",
которые заканчиваются после развода. Ну и возобновляться опять после следующей
свадьбы.

### Финализация

Добавим вишенку к торту: забекапим репозиторий и запушить всех людей на GitHub,
GitLab, либо любой другой сервер, поддерживающий Git (GitLab, Bitbucket).
Тоже изи! Можно пушить все ветки одна за другой, но с помощью взмаха волшебной
палочки запушим их все.

```
git remote add origin https://gitlab.com/KvanTTT/GenealogyTreeInGitTest.git
git push origin --all -u --force
```

## Примеры

В качестве маленького примера я запушил свое генеалогическое дерево, а в качестве
большого - дерево президентов США. Они доступны в репозиториях
[Kochurkins](https://github.com/KvanTTT/Kochurkins.git) и
[Presidents](https://github.com/KvanTTT/Presidents.git) соответственно. Создавал
я свое дерево еще давно в сервис [geni.com](geni.com), откуда экспортировал в формат
gedcom.

![Presidents](Presidents.png)

На GitHub, да и на GitLab можно перемещаться по предкам и потомкам - это почти
что похоже на генеалогическую вики-систему типа [Familypedia](http://familypedia.wikia.com)
или [WeRelate.org](https://www.werelate.org). Правда гит*абы в чем-то даже более
круты: из них деревья легко выкачиваются (с помощью команды `--clone`),
но главное, можно открыть сразу весь граф, причем делать это можно с помощью
разных инструментов (веб-сервис, [GitExtesions](https://gitextensions.github.io/),
[Sourcetree](https://www.sourcetreeapp.com/),
[GitKraken](https://www.gitkraken.com/)
и других). В существующих генеалогических программах почему-то с открытием
всего графа возникали сложности.

Забавно, в гит*абах доступно даже какое-то подобие аналитики: можно узнать у кого
самая ~~инстаграмная жизнь~~ насыщенная событиями жизнь. Ну или самая открытая.
На вкладке `Insights` отображается топ личностей в порядке уменьшения коммитов.

## Заключение

К сожалению пока что не очень ясно как можно дополнять историю с рутов - пока что
приходится генерировать ее полностью из gedcom файла. Не исключаю что это
как-то можно сделать с помощью хитрого рибэйза. Также неплохо бы переписать код
чтобы он работал "коммито-ориентированно", а не "событийно-ориентированно", т.к.
это нативней с точки гита - на самом деле ветви в нем являются последовательностью
коммитов, а не отдельными сущностями. Еще я думал как можно привязать
[теги](https://git-scm.com/book/ru/v1/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8)
к нашей концепции, но решил что ветвей достаточно.

Помимо генеалогических деревьев, можно ~~превращать другие буханки хлеба в троллейбусы~~
кодировать в гите генеалогические деревья языков (что еще более по-кодерски),
деревья разбора и вообще любые древовидные структуры. Практическая польза тоже есть:
разминка помогла лучше понять устройства гита, его команды, а также формат описания
генеалогических деревьев gedcom.

Еще раз поздравляю с днем программиста, желаю больше ярких коммитов на ваших
ветвях, больше форков, меньше незапланированных мержей и чтобы ветки не
запечатывались как можно дольше!