# Генеалогическое дерево внутри Git

Поздравляю всех с днем программиста, желаю больше ярких коммитов,
принятых пулл-риквестов, за которых не стыдно, меньше незапланированных мержей
и чтобы ваши ветки оставались актуальными как можно дольше! Не очень понятно?
Предлагаю прочитать данную статью, в которой я описываю как реализовал одну
безумную идею: генеалогическое дерево средствами системы контроля версий Git,
в которой ветвями являются люди, которые получаются объединения других ветвей,
родителей, и которые порождают дочерние, детей. Ну что же, звучит как план!

![Kochurkins](Kochurkins.png)

Для тех сразу все понял выкладываю исходники генератора: [GenealogyTreeInGit](https://github.com/KvanTTT/GenealogyTreeInGit.git)
и сами генеалогические деревья: [мое](https://github.com/KvanTTT/Kochurkins.git)
и [президентов США](https://github.com/KvanTTT/Presidents.git).

Кроме того, я пошел дальше и реализовал простой [**социальный граф**](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84).
Он отображает не только степень родства, но и статус отношений между потомками,
отображает такие события как свадьба, развод, рождение ребенка, а также вклады в
отношения тех или иных сторон.

<cut text="Читать дальше о реализации, подробностях, а также смотреть картинки">

## Git

<table>
  <tr>
    <td width=100><img src=Git.svg ></td>
    <td>Напомню, что <b>Git</b> - одна из самых популярных систем контроля версий.
      Она мощная: в ней можно фиксировать изменения (commit), создавать и сливать
      ветви (checkout и merge), сравнивать разные версии файлов (diff), вычислять
      авторов конкретных строк (blame), а также делать многие другие вещи.
    </td>
  </tr>
</table>

К счастью или к сожалению, Git в чем-то похож на государство-победителя: он
позволяет менять историю, а именно менять даты, сообщения и авторов коммитов.
Но это наоборот содействует, поскольку позволяет добавлять членов семьи,
как будто они авторы событий, сделанных в конкретную дату.

Начал я с простого: написал несколько команд и вуала: фрагмент дерева готов.
Отлично, теперь надо это проделать со всем армией родственников. Я с радостью
напишу для них 200 строчек команд, в которых можно запутаться,
а для президентов - все 10К!

<!-- TODO добавить картинку -->

Добавили меня в список идиотов? Вычеркивайте - конечно же я автоматизировал
процесс и написал приложение для конвертации генеалогических данных в
последовательность команд гита. Существуют несколько форматов таких данных, но я
выбрал **Gedcom**.

## Gedcom

<table>
  <tr>
    <td width=100><img src=Gedcom.svg ></td>
    <td><b>Gedcom</b> - формат описания генеалогических деревьев. Довольно старый,
        но текстовый и в целом простой. Поддерживается чуть ли не всеми
        генеалогическими программами, поэтому примеров для него существует <a href="https://webtreeprint.com/tp_famous_gedcoms.php">множество</a>:
        дерево президентов США, королевской династии, Шекспиров.</td>
  </tr>
</table>

Спецификация формата неплохо [описана](https://ru.wikipedia.org/wiki/GEDCOM) в
интернете, так что дополнительно его описывать я не буду.

Реализоввал все это безобразие на [.NET Core](https://www.microsoft.com/net/learn/get-started-with-dotnet-tutorial) -
он удобный и кроссплатформенный. Для парсинга и обработки gedcom есть несколько
библиотек под C#: [GeneGenie.Gedcom](https://github.com/TheGeneGenieProject/GeneGenie.Gedcom),
[gedcomx-csharp](https://github.com/FamilySearch/gedcomx-csharp) и другие.
Я решил написать собственную на основе [GedcomParser](https://github.com/jaklithn/GedcomParser),
ну потому что она обладает [фатальным недостатком](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D0%B4%D1%80%D0%BE%D0%BC_%D0%BD%D0%B5%D0%BF%D1%80%D0%B8%D1%8F%D1%82%D0%B8%D1%8F_%D1%87%D1%83%D0%B6%D0%BE%D0%B9_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8).
На самом деле нет: мне захотелось самому лучше разобраться в формате и избавиться
от всех зависимостей, что позволит при желании легко портировать проект на другие
языки.

## Генерация команд

Настал момент обхода извлеченных личностей в удобном нам формате и генерации
команд Git для них. Было решено отсортировать все события в хронологическом
порядке, а затем создавать ветки, мержить и коммитить их, продвигаясь в порядке
возрастания дат. К сожалению, не у всех событий есть даты, поэтому пришлось изрядно
повозиться чтобы отсортировать все события правильно. На носу 2^2^3, а я осознал
что такой подход не совсем правильный, так как при обходе в глубину с датами
возиться бы вообще не пришлось. Исправлюсь позже (но это не точно).

### Инициализация

Все что требуется на этом этапе - инициализировать репозиторий:

```
mkdir Family
cd Family
git init
```

### События

В этой части скрипта обходятся и коммитятся все события. Для этого использовались
такие команды:

* `git checkout --orphan branch_name`
* `git merge @I1@ --allow-unrelated-histories --no-commit`
* `git commit -m "msg" --date "" --author "name <email>" --allow-empty`

Первая, `checkout`, создает ветвь для каждой личности. Флаг `--orphan` позволяет
создавать ветки-сироты, т.е. ветки не имеющие родителей. Ветка-сирота создается
один раз - при последующем переключении `checkout` этот параметр опускается.
В конечном итоге практически все коммиты имеют родителей, за исключением самых
дальних предков, потому что для них более ранние неизвестны.

Вторая команда, `merge`, объединяет родителей и создает ребенка. Будем писать в
сообщении коммита Birth - рождение с соответствующим годом. Также указываем флаги
`--allow-unrelated-histories` и `--no-commit` возможности мержить ветки-сироты и
для того, чтобы закоммитить изменения позже. Некоторые дети являются приемными,
поэтому для них будем писать Adopted. Забавно, но Git позволяет создавать шведские
семьи, т.е. мержить одновременно несколько веток. А еще, кстати, ветки не имеют пола.

Наконец, третья команда, `commit`, создает коммит с сообщением `-m`,
датой `--date` и автором `--author`. Как уже писал, Git позволяет подменять сообщение,
автора и дату коммита. Более того, Git позволяет создавать коммиты без файлов с помощью
флага `--allow-empty` и без сообщений с помощью `--allow-empty-message`. У автора также
необходимо указывать электронную почту, но Git принимает и пустую - нужно просто
передать `<>`. К сожалению, Git не уважает стариков: дата коммита почему-то снизу
ограничена 1 январем 1970 года - более ранняя дата будет неправильно отображаться.
Однако все не так страшно: можно просто записывать реальную дату в
описание. Тем не менее, Git верит в будущее и принимает даты в будущем - обратите
внимание на моего сына Git. Матерей- и отцов-одиночек, кстати, тоже можно
создавать.

#### Социальный граф

В нем фиксируются и другие события помимо рождения: крещение, изменение места
жительства, получение образования, женитьба, развод, смерть, похороны.
После смерти ~~ветвь попадает в цифровой рай~~ в ветви невозможно появление
последующих событий, кроме разве что похорон. На сервере такую
ветвь вообще можно запечатать, т.е. сделать [protected branch](https://help.github.com/articles/about-protected-branches/)
(не волнуйтесь: в будущем "воскресить" можно будет при необходимости).

Событие "Свадьба" имеет двух предков, супругов. А "Развод" имеет одного предка,
предыдущее событие "Свадьба". Над семейной жизнью надо работать как и над детьми,
поэтому можно сказать что после свадьбы появляется еще и новый потомок "отношения",
которые заканчиваются после развода. Ну и возобновляются опять после следующих
циклов свадьба-развод.

Также в отношениях могут участвовать несколько человек (слияние нескольких веток).

### Финализация

Добавим вишенку к торту: сделаем бекап репозитория и выгрузим всех людей на GitHub,
GitLab, либо любой другой сервер, поддерживающий Git. Можно пушить все ветки
одна за другой, но с помощью взмаха волшебной команды запушим их все, что намного
быстрее и проще:

```
git remote add origin https://gitlab.com/KvanTTT/Family.git
git push origin --all -u
```

Для генерации обычного генеалогического дерева нужно передавать флаг
`--only-birth-events` при запуске генератора. В этом случае будет создаваться
по одному коммиту на человека, а именно "рождение". В противном случае будет
генерироваться ~~социальная сеть~~ социальный граф.

## Примеры

В качестве небольшого примера, который по крайней мере везде откроется, я создал
свое генеалогическое дерево, а в качестве большого - дерево президентов США (2145 человек).
Они доступны в репозиториях
[Kochurkins](https://github.com/KvanTTT/Kochurkins.git) и
[Presidents](https://github.com/KvanTTT/Presidents.git) соответственно. Для создания
своего я использовал сервис [geni.com](https://geni.com), откуда экспортировал
дерево в gedcom. Сгенерированный скрипт создания генеалогического репозитория
доступен в [gist](https://gist.github.com/KvanTTT/4a713955a54a062313d43ebb5a96824a).

[![Presidents](Presidents.png)](https://github.com/KvanTTT/Presidents.git)

На GitHub, да и на GitLab можно перемещаться по предкам и потомкам - это похоже
на генеалогические вики-системы [Familypedia](http://familypedia.wikia.com)
или [WeRelate.org](https://www.werelate.org). Правда гит(х|л)абы в чем-то даже
более продвинуты: из них деревья легко выкачиваются (с помощью команды `--clone`).
А главное, можно открыть сразу весь граф, причем делать это можно с помощью
разных инструментов (веб-сервис, [GitExtesions](https://gitextensions.github.io/),
[Sourcetree](https://www.sourcetreeapp.com/),
[GitKraken](https://www.gitkraken.com/)
и других). В существующих генеалогических программах почему-то возникали сложности
с открытием в полном объеме даже небольших графов. Кроме того, эти сервисы
можно использовать бесплатно, в отличие от большинства генеалогических.

Примечательно, в гит*абах доступно даже какое-то подобие аналитики: можно узнать
у кого самая ~~инстаграмная жизнь~~ насыщенная событиями жизнь. Ну или самая открытая:
на вкладке `Insights` отображается топ личностей в порядке уменьшения коммитов.

[![Pulse](Presidents-Pulse.png)](https://github.com/KvanTTT/Presidents/pulse)

К сожалению, большие деревья хабы отображают некорректно, однако хранят их
правильно - можно затянуть репозиторий и убедиться в этом. Вот как выглядит
мое дерево в веб-интерфейсе гитлаба:

[![Kochurkins GitLab](Kochurkins-GitLab.png)](https://gitlab.com/KvanTTT/Kochurkins/network/@I1@)

## Проблемы

Пока что не очень ясно как можно дополнять историю с корней - пока что
приходится генерировать ее полностью из gedcom файла. Не исключаю что это
как-то можно сделать с помощью хитрого рибэйза - можете поэкспериментировать и
рассказать в комментариях.
Также было бы неплохо переписать код чтобы он работал "коммито-ориентированно",
а не "событийно-ориентированно", т.к.
это естественней с точки гита - на самом деле ветви в нем являются последовательностью
коммитов, а не отдельными сущностями. Еще я думал как можно привязать
[теги](https://git-scm.com/book/ru/v1/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8) и
[подмодули](https://git-scm.com/book/ru/v1/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D0%BE%D0%B4%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8), но пока что
не придумал как это лучше сделать.

## Заключение

Если расширить идею генеалогических деревьев дальше, на веб-сервисы для разработчиков,
то с помощью [issues](https://help.github.com/articles/about-issues/)
можно заводить разные глобальные задачи и распределять их по разным [вехам (milestone)](https://help.github.com/articles/about-milestones/):
детство, отрочество, взрослая жизнь, старость.

Помимо генеалогических деревьев, можно ~~превращать другие буханки хлеба в троллейбусы~~
кодировать в гите генеалогические деревья языков программирования
(что еще более по-кодерски), синтаксические деревья и вообще любые древовидные структуры.
Гит можно освоить и домохозяйкам, чтобы выстраивать взаимосвязи между героями
бразильских сериалов :)

Практическая польза от всего этого тоже есть: такая разминка помогает лучше
понять устройство гита, его команды, а также формат описания генеалогических
деревьев gedcom.

*Исходники самой статьи [доступны на GitHub](https://github.com/KvanTTT/Articles/tree/master/Genealogy-Tree-In-Git) -
присылайте Pull Request туда если найдете ошибки или захотите дополнить контент.
Для конвертации в формат habr.com используется библиотека [MarkConv](https://github.com/KvanTTT/MarkConv).*